Functions
-----------

* start with def
* no return type - either what return statement returns or None. (not last statement stuff)
* args have  no type either.
* function are objects too..
* invoked with fnName(args) [dont forget parenthesis for empty-arg fns]

eg:

def add(a,b):
  c=a+b
  return c

add(5,10)


Commenting comments
-------------------

* '''...''' right after the function defintion
* function.__doc__ is the way to get the doc-string of a function
* Simple comments begin with #

Data-types
===========

booleans
numbers
strings
bytes and bytearray
lists
tuples
sets
dictionaries

* use type(variable) to check the type of a variable.

casting
~~~~~~~

str(anything)       # for class-types, it invokes __repr__ of the class
int(string_var)
float(strint_var)   # yes. it coverts to double precision


List
----

* list is [ .. ] separated by comma
* list elements are indexed from 0 and name[0] is the way to get one element
* -1 is the last element.
* slicing is first index to *one before* the second index.
* slicing generally creates a reference to a list. However, in the a[:] form,
  Slicing creates a copy, so a[:] is a shorthand for getting a copy of a list
* l[:size] -> will give u first size elements
* l[size:] -> will give u from size'th index (i.e size+1th element) till end
* lists never have gaps

len(a)
a.append(one_value)
a.extend([list])
a.insert(index,value)  # Use this for inserting at head/index-0 !
del a[index]   # list size reduced by one. and all indices index+1:<end> .. become index:<end>
a.pop()  # pops the last index, gets a IndexError when we pop a empty list. List reduces after pop.
a.pop(index)  # pops given index
a.remove(value)  # pops vlaue. raises ValueError if value is not found
a.index(value)  # gives index of the value.
sorted(a)   # Gives a new list which is sorted a.
str.join(list_x)  # joins each element in list_x with str as the joining character .. eg: ' '.join(['hello','world'])

#LIFO (stack) -> append/pop() is equialent of push/pop
#FIFO (queue) -> append/pop(0) is equialent of insert_tail/pop_head
                 insert(0,val)/pop() is equialent of insert_head/pop_tail


value in a # boolean expression to check if value is in a list. WORKS FOR STRING AS WELL

for value in a:
  # .. use value

+ operator concatenates lists

list.sort()  -> sorts the list in place. So better than sorted(list) if u dont need orig-list.
             -> sorted() takes any iterable, but list.sort() is available only for lists.
Both sorted and list.sort() take a named key arg. This is a function with one-arg and returns
         a value, which is used as the value to be sorted. (Efficient as this func is called 
         only once for each member). Lambda's are typically used here..



Tuples
-----

* Use ( , .. , ) for types instead of squarebracket.
* (tuple1) = (tuple2)
    eg: (x,y,z) = (1,2,3) is a conveneient way to assign multiple variables respectively


Sets
-----

* Use { , .. , } for sets
* sets dont remember order of their elements
* values in the sets are unique.

a.add(value)  # adds a value to set if its not already present.
a.update(value, set, list) # addes the value, members of set, list to the set.
a.discard(value)  # removes the value from set. No error if value not present
a.remove(value)  # removes the value from set. KeyError is raised if value not present.
a.pop()          # removes some arbitrary member from set. KeyError on empty set
a.clear()         # clears the set. same as a=set()

a.union(b)  # returns a *new* set that is union of a & b
a.intersection(b)
a.difference(b)             # in a not in b
a.symmetric_difference(b)   # in strictly only of a and b

Note: a= {} creates a empty *dictionary*, not set.

Dictionary
------------

* user { key:value } for dictionary

a[key] = value  # for assignment or referenence. Note they key is indexed using squre braket only!

a.keys()    # gives a list of keys of dictionary a, not necesarily in sorted order .. probably iterable in py-3
a.vaues()   # gives a list of values
a.items()   # gives a list of tuple of (key, value) from a dictionary

a.pop(key [, default])   # dels the key and returns its value. If key isn't present default is given. If default isn't supplied KeyError is generated

#when iterating over dict, u typically iterate over keys
for key in a_dict:

# if u need boht key and value, then use iteritems
for key,value in a_dict.iteritems()

orig_dict.update(another_dict)

List comprehesion
------------------

[ expression-having-variable for variable in origList ]
[ expression-having-variable for variable in origList if condition ]

so is it with dictionary and set comprehesion

{ expression_with_i:another_expression_with_i for i in a_list if condition }


strings
---------

* Every string is a UTF-8 encoded sequence of characters in python-3.
* strings can be single or double-quoted(abs no diff. This helps to avoid escaping either). Triple single quotes is for long strings. r'raw \.string' is a raw strings
* + is a way to concatenate strings

a.splitlines()       # list of lines. The restult wont have carriage returns.
a.lower()            # returns a new string that has all lower caps
a.upper()
a.count('f')         # counts no of substrings
a.split(delimiter,times)   # splits a string based on delimiter. THe second is optional and gives number of times the slice should be done.

a.encode('utf-8')    # gives a bytes object

a.index()
haystack.find(needle [,start [,end]])  # give index in haystack where needle is found, -1 on failure, start:end as in slicing
a.replace()

a.rfind()  # find from end.

a.strip()            # trim whitespaces
a.rstrip()
a.lstrip()
a.replace(what_to_replace,to_replace_with,[,max])   #bbbbbb

ord(a)    # gives the ordinal value of a, give just one char as input
chr(num)  # inverse of ord

UnicodeEncodeError
~~~~~~~~~~~~~~~~~~

ascii_form = unicode_data.encode('ascii','ignore')
ascii_form = unicode_data.encode('ascii','replace')  # you get '?' for every non-ascii
ascii_form = unicode_data.encode('ascii','xmlcharrefreplace')  # you get &#<num>; for every non-ascii


bytes
-----

defined as b'\xfe' or b'abc'

a=b'\x65\x48'        # a bytes object
a.decode('ascii')    # gives a string object. 
                     # encode/decode complement bytes/str conversion

bytes like string is immutable
bytearray is mutuable

Extra ones.
----------

collections.deque
   -> like list, but has front and back at O(1)

collections.orderedDict
   -> A bit useless. Order is maintained on insertion order of keys.
   -> This is more standard than the SortedContainers below. So use this if it solves the purpose

SortedContainers.sortedDict
   -> A proper dict based on key.
   -> Looks like there is getNextAfterKey()/..Before.. [use bisect() and peekItem()]

llist.dllist
  -> A doubly linked list in python. If you really wanted a linked list.

Import path
-----------

sys.path is the list of locations looked fork

control structures
------------------

if condition:
  ...
elif next_condition:         #python's else if style
  ..
else
  ..

with lists.
  Use range function to run over a range.
  range(start-value, end-value+1, increment)

for i in list:
  ..use i..

for i in range(1,10):
  ..use i..

break
continue

Want to iterate over 2(or more) lists of the same length simulataneously?
 -> Keep them as one list of tuples!
eg:
student=['s1','s2','s3']
mentor=['m1',m2','m3]
count = 0
for s in student:
  print s,m[0]

can instead be:

student_mentors=[('s1','m1'),('s2','m2'),('s3','m3')]
for (s,m) in student_mentors:
  print s,m



logical operators
-----------------

and
or
not


variable args to function
-------------------------

def manyArgs(arg1, arg2, *args, **kwargs):
  #arg1, arg2 are std args
  #args is a tuple of all unnamed args
  #kwargs is a dict of all named args


swap 2 variables
----------------

a,b = b,a


class
-----

class Name:
  #There is no explicity declaring of members

  count = 0                     # Can be used like static in c++, but see notes below

  def __init__(self,arg1,arg2):
    self.member1=arg1           #automaticaly adds member1 as a field to the class objects.

  def function(self,arg1):
    pass                        #all member function's first arg is self.
    self.anotherMember(arg2)    #remember to put the self before calling another member from member
    Name.count++;               #refering a Name.member brings in a c++-style static member of the class.

  @staticmethod
  def function(arg1):
    pass                        # note the absence of self for static member functions. Invoked as ClassName.function()
    Name.count++;               #refering a Name.member brings in a c++-style static member of the class.


#Later..
n = Name(10,12)

* The attributes of a class are kind of public. No data-encapsulation.
* In fact, attributes of a class can be added at will anytime. There is really no
  fixed-set of attributes for a class
  n.newAttribute = "abc"   # is perfectly valid anywhere!
* ClassName.var_name  # when used with ClassName refers to a var_name in class-scope(static like)
                      # DONT FORGET the ClassName - otherwise, it just uses/refers to a local var.
* methods in the class can work on static members as long as they use ClassName to scope it.
* But instance_var.var_name  # when assigned to, will create a instance level attribute!

class Derived(Base):
  def __init__(self, derived_args):
    Base.__init__(self, base_args)
    self.derived_member = derived_args

Magic attributes of a class
~~~~~~~~~~~~~~~~~~~~~~~~~~~

n.__class__    # reference to a object of type class, which represents the class-definition
n.__doc__      # reference to the doc-string
n.__repr__     # is a function, that will used to stringize the class. 
               # Tip, it takes mandorty self, u can actaully pass more args
               # as long as u have default-args.

hasattr(object, "member")  # check if object.member exists
setattr(object, "member", "value")

Global scope
------------

var  = 5;     #global scope - outside of any function

def func():
  global var
  var = 6        #updates global var as it explicity mentiond

def func2()
  var = 6        #silently creates a local var and uses that. Doesn't reflect glboal var.

lambda
-------

lambda arg1 [, arg2,..]: manipulate(args)

map
---

Gives a generator, where the given fn is applied on the list provided.

map (fn_to_apply, list_of_inputs)

Iterators
---------

* A class that implements __iter__ , which returns a object that implements __next__
* Typically its customary to return self in __iter__ and implemen __next__
* User calls next() and gets StopIteration error at end.


Generator
---------

* Is a function (defined with def Name():)
* But has a yield statement in it.
* You have to first create a object by calling generate_name() [read, generate_name param param]
* Later you call gentr.next() to start getting values out of it.
* When its done, you get StopIteration thrown (This happens when generator code falls off its def block)
* On actual invocation (creation of object), no code gets executed.
* On first next, code gets executed till yield which is returned outside
* On susequent next()'s, code continues from yield till yield is hit again. Note taht all vars in
  the def block remember their values
* When code falls off the def-block, we get StopIteration thrown to the next() caller.

----
# a generator that yields items instead of returning a list
def firstn(n):
    num = 0
    while num < n:
        yield num
        num += 1

sum_of_first_n = sum(firstn(1000000))
----

Generator expressions
---------------------

* syntactically different form Comprehension with a parenthesis!
* Generators are cheaper than comprehension as the list isn't created right away

(expression for i in origList)

closures
----------

* A (typically anonymous) function that takes arguments (like normal function) and has a state inside it.
* The state is set up in the closure at the time of its creation.
* The closure can mutate its state during every invocation
* Multiple instances of the same closure function can have different states.
* At the outset, you will see a function having a inner function, and returning the inner function

A closure is typically created like this

def create_a_closure(state1_for_closure):
  state2_for_closure = "some_initial_value"
  def my_closure(closure_arg1, closure_arg2):
    result = work_on(state1_for_closure, state2_for_closure, closure_arg1, closure_arg2)
    state1_for_closure = "new_values"  # Note this state was setup at closure create time (call of create_a_closure)
    state2_for_closure = "new_values"  # Note this state was setup at coding time
    return result
  return my_closure

#Later
a_closure = create_a_closure("intial_value_for_state1")

decorators
-----------

* The intent of a decorator is to wrap around any function with added behavior
* You write a closure like situation, where a function takes one function as arg, which defines a inner funciton and returns it.
* The inner funciton does fancy stuff (and calling the actual supplied function)
* Later you can just use the decorator syntax 
@decorator_name
def function_that_will_be_wrapped(...):
  ...

* Users just invoke normally with function_that_will_be_wrapped() and that gets wrapped by the decorator

itertools
----------

itertools.permutations(iterable, size_to_work)
itertools.combinations(iterable, size_to_work)
itertools.product(iterable, iterable)           -> (1,a), (1,b), (1,c), (2,a), (2,b), (2,c)
itertools.groupby(iterable,keyfunc)             -> listof (keyvalue, sub-iterators) Note: given iterable Must be already sorted/sub-sorted.
itertools.chain(it1,it2,..itn)                  -> single iterator that goes over all
itertools.zip(it1,it2,..itn)                    -> single iterator that goes over tuples of members of all iterables. Stops at shorted.
itertools.zip_longest(it1,it2,..itn)            -> ..zip till longes, filling None for thse that are over.

#infinte iterators
itertools.cycle(iterable)                       -> keeps cycling on the iterable endlessly

reversed(iterable)                              -> native way to reverse any interable

Simple commands
----------------

print()   # also prints a "\n" at end of string

print "happy arg:%d"%arg,  # the trailing comman skips the newline

print('.',end="",flush=True)   # to control "\n" and flushing  .. only in python 3
sys.stdout.flush()  # in python 2

print('string',file=sys.stdout)  # to a file

https://pyformat.info/

string.format(args)
'{0} {1:2d}'.format(s,i)
'{0:b}'.format(i)               # is a quick way to print a number in binary

By default format calls __format__ of the object.
Use !r !s or !a to call __repr__, __str__, ascii()
{0!r:}

align right/left/center : > , -, ^

{<arg-position><convertion-flag>:<padding-char><align><width>.<trunc-width><type>}  # default type is string

older python:

# use this and use print statement.
from __future__ import print_function

print "format string %d, %s, %s"%(int_var,str_var,"string literal")


Error handling/Exception
--------------

try:

except IOError:

# Note its except and not expect

* No one defines what exceptions will be raised. We handle every possible exception
* keyword to throw in python is raise

def function():
  ...;
  if problem:
    raise IOError;
  ...;


Various ways to catch exceptions:

except IOError as e:
  e.whatever..
  e.errno
  e.strerror

Capture all Exceptions!

except Exception,e:
  print str(e)



Reading file line by line:
--------------------------


with open("file","r") as fp:
  for i in fp:                  # This is efficient on large files. so *ok for big files*
    print(i)

with open("file","r") as fp, open("second-file","r") as fp2:   # for multiple files

f.readlines()   # gives each line of file in a list.. Note: Entire file is gobbled in one-go. Useful *only for small files.*
f.read()        # gets entire file as one big string. Again, use for small files only.

Reading line by line from stdin:

import fileinput
for line in fileinput.input():   #this one will pick stdin or if some arg(s) is/are given, it will open that as a file!
  pass

import sys
for line in sys.stdin:
  print line

for line_number, line in enumerate(fd):   # will also get line-number along

enumerate(iterable,start_value=0)         # will start value from start_value

To find if a variable is a list/scalar

if isinstance(var_name, list):


User input (from stdin, keyboard)
----------

#what you probably need most of the time
variable=raw_input("Prompt string w/o newline:") # Gets whatever is given and assigns to variable which is now a str. You then cast this string into whatever you want.

#also know:
variable=input("Prompt string w/o newline:")     # Gets user-input and interprets it as a python-expression! Thus unquoted string-literals are interpreted as var-names
                                                 # Most likely not what you want. But if you type in a int, your variable also holds a int-object directly.

Use readline library
~~~~~~~~~~~~~~~~~~~~
import readline
import atexit

def rlinput(prompt, prefill=''):
  readline.set_startup_hook(lambda: readline.insert_text(prefill))
  try:
    return raw_input(prompt)
  finally:
    readline.set_startup_hook()

historyPath = os.path.expanduser("~/.pyhistory")

def save_history(historyPath=historyPath):
    import readline
    readline.write_history_file(historyPath)

if os.path.exists(historyPath):
    readline.read_history_file(historyPath)

atexit.register(save_history)

Arg parse
--------

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-v","--verbose", help="increase output verbosity", action="store_true")       # captures if --verbosity present or not in arg-list. No arg per-se for this option.
parser.add_argument("-v","--verbose", help="increase output verbosity", action="count")            # captures how many times --verbosity was present in arg-list. No arg per-se for this option.
parser.add_argument("-v","--verbose", help="increase output verbosity", type=int)                  # --verbosity <int>
parser.add_argument("-v","--verbose", help="increase output verbosity", type=int, choices=[0,1,2]) # --verbosity <0|1|2>
parser.add_argument("str_arg",   help="give a string argument (this is a mandatory argment)")
parser.add_argument("int_arg",   help="give a int arg (this is a mandatory argment)", type=int)
parser.add_argument("optional",  help="User may skip this", nargs="?", default="abc")
parser.add_argument("many_optional", help="User may give zero or  more of this and this will be a list", nargs="*", default=["a","b"])

# dash- is converted to underscore

parsed_args = parser.parse_args()
parser.add_argument("-v","--verbose", help="increase output verbosity", action="store_true")       # captures if --verbosity present or not in arg-list. No arg per-se for this option.
if parsed_args.verbose:
      print("verbosity turned on")

also:
group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", action="store_true")
group.add_argument("-q", "--quiet", action="store_true")

argc/argv example
-----------------

if len(sys.argv) < 2:
    sys.exit('Usage: %s database-name' % sys.argv[0])

if not os.path.exists(sys.argv[1]):
    sys.exit('ERROR: Database %s was not found!' % sys.argv[1])

exiting from python
---------------------

sys.exit(0)

regular expression  regexp regex
------------------

import re
m =  re.search (pat, haystack)   # m is a match object or a None

m.group()  # gets the matched string
m.group(1)  # gets the 1st left paren group.

a = re.findall (pat, haystack)  # gets the list of all matches.. if he pat has (), then it gets back a list of tuples

a = re.sub(pat,replacement,src_string,count=0,flags=0)  # replace can use \1 to backref.

#remove invalid filename chars for windows
valid_filename = re.sub(r'[\\/:"*?<>|]+', "_", var_having_junk_chars)

# if u are using a regex a lot, pre-compile it

pat_object = re.compile(pattern,flags)
pat_object.search(haystack)
pat_object.match(check_exact_match_input)

os-package (file manipulation stuff)
----------

os.path.join(dir,filename)
(dirname,filename) = os.path.split("abc/efg/file")       # dirname basename
(filename,extension) = os.path.splitext("filename.ext")  # note the spelling split-ext
os.path.abspath(path)
os.path.realpath(path)  # resolves sym-links!
os.path.exists('path/to/file')      #file check present
os.makedirs(path)   # no mkdir -p option.. just check isdir and then do this or do , catch except OSError (latter better)
os.getcwd()         # get cwd pwd
os.chdir(path)      # cd to a working-dir
os.path.dirname(os.path.realpath(__file__))   # get dir of current file

os.path.isfile('path')  # true if its regular file or sym-link to regular file
os.path.islink('path')  # true if its a sym link
os.path.isdir('path')   # true if its a dir or a sym link to a dir

# create/make a new dir , mkdir
if not os.path.exists(directory):
    os.makedirs(directory)

os.rename(src,dst)   # mv in python

os.remove(path)  #delete a file
shutil.rmtree(dir_with_contents)  # just delete a dir / folder with contents

# for quick and directy commands. Command o/p comes to stdout.
os.system("your command with all args in a single string")

import subprocess
subprocess.call(["ls","-l"])   # Just run it clobbering ur stdout with the cmd's stdout.
subprocess.check_output(["ls","-1"])  # Run and get the o/p as return value

boolean_variable=os.access("/path/to/file",os.F_OK)  # does file exist at all
boolean_variable=os.access("/path/to/file",os.R_OK)
boolean_variable=os.access("/path/to/file",os.W_OK)
boolean_variable=os.access("/path/to/file",os.X_OK)

To recursively walk a dir
~~~~~~~~~~~~~~~~~~~~~~~~~

# os.walk gives a generator that recurses into dirs.
# So our code looks nice and iterative!
for subdir, dirs, files in os.walk(a_given_dir):
  print "files in %s"%subdir
  for f in files:
    fname = os.path.join(subdir, f)
    print(fname)
  print "dirs in %s"%subdir
  for f in dirs:
    fname = os.path.join(subdir, f)
    print(fname)

To just list one level
~~~~~~~~~~~~~~~~~~~~~~

os.listdir(given_dir)

To filter only dirs:
[ name for name in os.listdir(given_dir) if os.path.isdir(os.path.join(given_dir, name)) ]

or

#if you dont want to pass to stdin
a=subprocess.Popen(["ls","-l"],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output,err=a.communicate()
errcode = a.wait()
print output

#if you have a  stdin to poass
output,err=a.communicate('Any string as in input if needed')
a=subprocess.Popen(["ls","-l"],stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output,err=a.communicate(input="Whatever you want to pass")
errcode = a.wait()
print output

# each command is one invocation to Popen, with its stdout/stderr set to the previous commands pipe.
# You can use subprocess.PIPE to ask popen to give you a pipe. THis is obtained by a call to communicate.
# the wait will wait till the command is done. errcode is the process return code. 0 if success, non-0 iff ailure
# The result of communicate is like a string, ready for processing.
# You can stack as many commands with a pipe arrangement.

# To do this following
#   ls *.mp3 | grep MS
from subprocess import Popen, PIPE
ls_process = Popen(['ls', '*.mp3'], stdout=PIPE)
grep_process = Popen(['grep', 'ms'],stdin=ls_process.stdout, stdout=PIPE)
ls_process.stdout.close() # enable write error in ls if grep dies
out, err = grep_process.communicate()

def execute_cmd(cmd, print_cmd=True, error_ok=False, print_op=False, dry_run=False):
  if print_cmd:
    print ("Executing :%s"%' '.join(cmd))
  if dry_run:
    return ""
  a=subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  output,err=a.communicate()
  errcode = a.wait()
  if err or (errcode != 0):
    if not error_ok:
       print("got a error,err:%s, errcode:%d"%(err,errcode))
       sys.exit(1)
  if print_op:
    print("Got:\n%s"%output)
  return output

import glob
list_of_filenames=glob.glob("*.py")

import sh
a=sh.ls('-1','.')

File locking
-------------


import fcntl
x = open('foo', 'w+')
fcntl.flock(x, fcntl.LOCK_EX | fcntl.LOCK_NB)
Unlocking is just as easy:

fcntl.flock(x, fcntl.LOCK_UN)

random
-------

random.seed([x])    # x is any hashanble object. if none is passed, sys-time is used.
random.shuffle(x)   # shuffles list x in place.
random.randint(a,b) # get a random int from [a,b], both included
random.sample(iterable,k=1)  # gets a k-sized tuple of items from iterable.


time
----

>>> import time
>>> st_mtime=1247520344.9537716
>>> time.localtime(st_mtime)
time.struct_time(tm_year=2009, tm_mon=7, tm_mday=13, tm_hour=14, tm_min=25, tm_sec=44, tm_wday=0, tm_yday=194, tm_isdst=1)
>>>

#sleeping in python
from time import sleep
sleep(0.1) # Time in seconds.

datetime
---------

#Note: datetime module has 2 objects - date  and datetime. (And a timedelta)

datetime.date.today()
datetime.datetime.now()    # same as today, but can accept a tz as optional name arg

datetime.datetime.strptime('time-in-string','format')   # read a time in a string in.
datetime.datetime.strftime('format')                    # print a time in a string

%d - 0 padded 2 digit date
%m - 0 padded 2 digit mth
%Y - 4 digit year
%H,%M,%S - 24-hr,min,sec as 0-padded-2-digit-numbers
%a - 3 digit weekday

datetime.timedelta is returned when you subtract 2 datetime.datetime objects

date = datetime_obj + datetime.timedelta(days=30)

Enums /enum
-----

from enum import Enum

class Color(Enum):
  Red = 1
  Yellow = 2

#Iterate over all enums
for c in Color:
  print (c)         # will print Color.Red, Color.Yellow

#To get string/number against a enum
Color.Red.name
Color.Red.value

#if u have number, to get enum object
Color(1)

#if u have string, to get enum object
Color['Red']


urllib
------

import urllib

uf = urllib.urlopen('http://google.com')
file_page = uf.read()

urllib.urlretrive('http://google.com/intl/en_ALL/images/logo.gif', 'blah.gif')

import urllib2, base64

request = urllib2.Request("http://api.foursquare.com/v1/user")
base64string = base64.encodestring('%s:%s' % (username, password)).replace('\n', '')
request.add_header("Authorization", "Basic %s" % base64string)   
result = urllib2.urlopen(request)

To supress warnings
^^^^^^^^^^^^^^^^^^^

import requests.packages.urllib3
requests.packages.urllib3.disable_warnings()

requests
--------

r = requests.get('https://api.github.com/user', auth=('user', 'pass'))

dictvar = requests.utils.dict_from_cookiejar(cookiejar)
cookies = requests.utils.cookiejar_from_dict(dictvar)

beautiful soup
--------------

import bs4

soup = bs4.BeautifulSoup(html_data,'html.parser')

# Look at the parts of a tag
tags = soup('a')
first_tag = tags[0]
print 'TAG:',first_tag
print 'URL:',first_tag.get('href', None)
print 'Contents:',first_tag.contents[0]
print 'Attrs:',first_tag.attrs

pickle
-------

pickle.dump(object_to_dump, write_file_handle)

ob = picke.load(read_file_handle)

pexpect
--------

child=pexpect.spawn("cmd",["arg1","arg2"])
try:
  result=child.pexpect(["regex1","regex2"], timeout=120)
  #result is 0-based index in the list
  #unfortunately EOF and TIMEOUT are always exceptions
except pexpect.EOF:
  #pass
except pexpect.TIMEOUT:
  

logging
--------

import logging
logging.basicConfig(filename="abc.log", level=logging.DEBUG)
# mode='w', will erase existing log file
# DEBUG, INFO, WARNING, ERROR, CRITICAL, FATAL

logging.debug("This is a debug message")

sess_logger = logging.getLogger("SESS")
sess_logger.setLevel(logging.DEBUG)
fh = logging.FileHandler('session.log')
fh.setLevel(logging.DEBUG)
sess_logger.add_handler(fh)
sess_logger.debug("This is a session subsystem log")

* Note: logging defers calling the arg's __str__ function. Do

logging.debug("This is fmt - %s and %s", some_object1, some_object2)
The actual invocation of some_object1.__str__() doesn't happen if debug level is diabled.

Context-manager
---------------

@contextmanager
def change_dir_to(new_dir):
  current_dir = os.getcwd()
  os.chdir(new_dir)
  yield
  os.chdir(current_dir)

Daemonizing
----------

import daemon

with daemon.DaemonContext():
    #whatever u want to daemonize
    main()


Post a json object
------------------

url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}
headers = {'content-type': 'application/json'}

response = requests.post(url, data=json.dumps(payload), headers=headers)

Find python version
-------------------

python -v

To make a script run if its main
--------------------------------

if __name__ == "__main__":

Curses
------

* window - is an internal representation containing an image of a part of the screen.
* screen - is a window with the size of the entire screen (from the upper left to the lower right)
* WINDOW stdscr - standard screen


Python Internals
---------------

Every name you see is a reference/pointer to an object.
The underlying object is either an immutable object or a mutable object.

Python library mgmt
--------------------

Typically python stores all its libraries in 

/usr/local/lib/python<ver>/site-packages
/usr/local/python<ver>/dist-packages

sudo apt-get install python-pip

and then

pip install <blah-blah>

or if u get the source

cd the-new-stuff
python ./setup.py install   # use the right python-version to install in its location

#List all installed libraries.
pip freeze

#list all files installed in a package
pip show -f <package>

reload a module in interpreter
------------------------------

#import again / re import / reimport
reload(module_name)

colorprint
----------

color_dict = { 'Black':0, 'Red':1, 'Green':2, 'Yellow':3,  'Blue':4,    'Magenta':5, 'Cyan':6,    'White':7 }

CSI='\033['
reset='\033[0m'

normal_foreground=30
normal_background=40
high_foreground=90
high_background=100

                          # foreground                        #background
chosen_color_prefix = CSI + str(30+color_dict[color]) + ';' + str(40+color_dict[color]) + 'm'

from colorama import Fore, Back, Style

colorama.init()
print(Fore.RED + 'some red text')
print(Back.GREEN + 'and with a green background')
print(Style.DIM + 'and in dim text')
print(Style.RESET_ALL)
print('back to normal now')

Fore: BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, RESET.
Back: BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, RESET.
Style: DIM, NORMAL, BRIGHT, RESET_ALL


Scapy
------

http://www.secdev.org/projects/scapy/files/scapydoc.pdf

import scapy.all

#capture
sniff(iface="nap301",filter="udp",prn=lambda x:x.summary(),count=10)

#convert pkt to str
str(pkt)

#list of fields values to stdout. Returns None
ls(pkt)

#print hexdump on stdout. Returns None
hexdump(pkt)

pkt.summary()
pkt.show()

pkt[IP]
pkt[IP].src
pkt[IP].dst
pkt[IP][UDP]
pkt[IP][UDP].sport
pkt[IP][UDP].payload


#ping
dip="10.10.1.1"
a=IP(dst=dip)/ICMP(id=RandShort(),seq=RandShort())/Raw("Random String")
reply=sr1(a)

#get o/p of tcpdump -xX
IP(import_hexcap())
0x0000:  4500 0034 8ecc 4000 4006 cfb8 0a1e 6402  E..4..@.@.....d.
0x0010:  0a1e 6401 0516 e811 afc4 2bb6 ba8d 2c21  ..d.......+...,!
0x0020:  8010 0041 143f 0000 0101 080a 2a32 2ab5  ...A.?......*2*.
0x0030:  1add 66e8                                ..f.
^D

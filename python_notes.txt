Functions
-----------

* start with def
* no return type - either what return statement returns or None. (not last statement stuff)
* args have  no type either.
* function are objects too..
* invoked with fnName(args) [dont forget parenthesis for empty-arg fns]

eg:

def add(a,b):
  c=a+b
  return c

add(5,10)


Commenting comments
-------------------

* '''...''' right after the function defintion
* function.__doc__ is the way to get the doc-string of a function
* Simple comments begin with #

Data-types
===========

booleans
numbers
strings
bytes and bytearray
lists
tuples
sets
dictionaries

* use type(varaible) to check the type of a variable.

List
----

* list is [ .. ] separated by comma
* list elements are indexed from 0 and name[0] is the way to get one element
* -1 is the last element.
* slicing is first index to *one before* the second index.
* Slicing creates a copy, so a[:] is a shorthand for getting a copy of a list
* lists never have gaps

len(a)
a.append(one_value)
a.extend([list])
a.insert(index,value)
del a[index]   # list size reduced by one. and all indices index+1:<end> .. become index:<end>
a.pop()  # pops the last index, gets a IndexError when we pop a empty list. List reduces after pop.
a.pop(index)  # pops given index
a.remove(value)  # pops vlaue. raises ValueError if value is not found
a.index(value)  # gives index of the value.
sorted(a)   # Gives a new list which is sorted a.
str.join(a)  # joins each element in a with str as the joining character .. eg: '\n'.join(a)

value in a # boolean expression to check if value is in a list. WORKS FOR STRING AS WELL

for value in a:
  # .. use value

+ operator concaetanates lists

Tuples
-----

* Use ( , .. , ) for types instead of squarebracket.
* (tuple1) = (tuple2)
    eg: (x,y,z) = (1,2,3) is a conveneient way to assign multiple variables respectively


Sets
-----

* Use { , .. , } for sets
* sets dont remember order of their elements
* values in the sets are unique.

a.add(value)  # adds a value to set if its not already present.
a.update(value, set, list) # addes the value, members of set, list to the set.
a.discard(value)  # removes the value from set. No error if value not present
a.remove(value)  # removes the value from set. KeyError is raised if value not present.
a.pop()          # removes some arbitrary member from set. KeyError on empty set
a.clear()         # clears the set. same as a=set()

a.union(b)  # returns a *new* set that is union of a & b
a.intersection(b)
a.difference(b)             # in a not in b
a.symmetric_difference(b)   # in strictly only of a and b

Note: a= {} creates a empty *dictionary*, not set.

Dictionary
------------

* user { key:value } for dictionary

a[key] = value  # for assignment or referenence. Note they key is indexed using squre braket only!

a.keys()    # gives a list of keys of dictionary a, not necesarily in sorted order .. probably iterable in py-3
a.vaues()   # gives a list of values
a.items()   # gives a list of tuple of (key, value) from a dictionary

orig_dict.update(another_dict)

List comprehesion
------------------

[ expression-having-variable for variable in origList ]
[ expression-having-variable for variable in origList if condition ]

so is it with dictionary and set comprehesion

{ expression_with_i:another_expression_with_i for i in a_list if condition }


strings
---------

* Every string is a UTF-8 encoded sequence of characters.
* strings can be single or double-quoted. Triple single quotes is for long strings. r'raw \.string' is a raw strings
* + is a way to concatenate strings

a.splitlines()       # list of lines. The restult wont have carriage returns.
a.lower()            # returns a new string that has all lower caps
a.upper()
a.count('f')         # counts no of substrings
a.split(delimiter,times)   # splits a string based on delimiter. THe second is optional and gives number of times the slice should be done.

a.encode('utf-8')    # gives a bytes object

a.index()
a.find()
a.replace()

a.strip()            # trim whitespaces
a.rstrip()
a.lstrip()

bytes
-----

defined as b'\xfe' or b'abc'

a=b'\x65\x48'        # a bytes object
a.decode('ascii')    # gives a string object. 
                     # encode/decode complement bytes/str conversion

bytes like string is immutable
bytearray is mutuable

control structures
------------------

if condition:
  ...
elif next_condition:         #python's else if style
  ..
else
  ..

with lists.
  Use range function to run over a range.
  range(start-value, end-value+1, increment)

for i in list:
  ..use i..

for i in range(1,10):
  ..use i..

break
continue

Want to iterate over 2(or more) lists of the same length simulataneously?
 -> Keep them as one list of tuples!
eg:
student=['s1','s2','s3']
mentor=['m1',m2','m3]
count = 0
for s in student:
  print s,m[0]

can instead be:

student_mentors=[('s1','m1'),('s2','m2'),('s3','m3')]
for (s,m) in student_mentors:
  print s,m



logical operators
-----------------

and
or
not



class
-----

class Name:
  #There is no explicity declaring of members

  count = 0                     # Can be used like static in c++, but see notes below

  def __init__(self,arg1,arg2):
    self.member1=arg1           #automaticaly adds member1 as a field to the class objects.

  def function(self,arg1):
    pass                        #all member function's first arg is self.
    Name.count++;               #refering a Name.member brings in a c++-style static member of the class.


#Later..
n = Name(10,12)

* The attributes of a class are kind of public. No data-encapsulation.
* In fact, attributes of a class can be added at will anytime. There is really no
  fixed-set of attributes for a class
  n.newAttribute = "abc"   # is perfectly valid anywhere!
* ClassName.var_name  # when used with ClassName refers to a var_name in class-scope(static like)
* methods in the class can work on static members as long as they use ClassName to scope it.
* But instance_var.var_name  # when assigned to, will create a instance level attribute!



Magic attributes of a class
~~~~~~~~~~~~~~~~~~~~~~~~~~~

n.__class__    # reference to a object of type class, which represents the class-definition
n.__doc__      # reference to the doc-string

Iterators
---------

Generator
---------

* Is a function (defined with def Name():)
* But has a yield statement in it.
* You have to first create a object by calling generate_name() [read, generate_name param param]
* Later you call gentr.next() to start getting values out of it.
* When its done, you get StopIteration thrown (This happens when generator code falls off its def block)
* On actual invocation (creation of object), no code gets executed.
* On first next, code gets executed till yield which is returned outside
* On susequent next()'s, code continues from yield till yield is hit again. Note taht all vars in
  the def block remember their values
* WHen code falls off the def-block, we get StopIteration thrown to the next() caller.



closures
----------

* A (typically anonymous) function that takes arguments (like normal function) and has a state inside it.
* The state is set up in the closure at the time of its creation.
* The closure can mutate its state during every invocation
* Multiple instances of the same closure function can have different states.

A closure is typically created like this

def create_a_closure(state1_for_closure):
  state2_for_closure = "some_initial_value"
  def my_closure(closure_arg1, closure_arg2):
    result = work_on(state1_for_closure, state2_for_closure, closure_arg1, closure_arg2)
    state1_for_closure = "new_values"  # Note this state was setup at closure create time (call of create_a_closure)
    state2_for_closure = "new_values"  # Note this state was setup at coding time
    return result
  return my_closure

#Later
a_closure = create_a_closure("intial_value_for_state1")

Simple commands
----------------

print()   # also prints a "\n" at end of string

print "happy arg:%d"%arg,  # the trailing comman skips the newline

print('.',end="",flush=True)   # to control "\n" and flushing  .. only in python 3

string.format(args)
'{0} {1:2d}'.format(s,i)

{arg-position:<width><type>}  # default type is string

older pythong:

print "format string %d, %s, %s"%(int_var,str_var,"string literal")


Error handling/Exception
--------------

try:

except IOError:

# Note its except and not expect

* No one defines what exceptions will be raised. We handle every possible exception

def function():
  ...;
  if problem:
    raise IOError;
  ...;


Various ways to catch exceptions:

except IOError as e:
  e.whatever..




Reading file line by line:
--------------------------


with open("file","r") as fp:
  for i in fp:                  # This is efficient on large files.
    print(i)

f.readlines()   # gives each line of file in a list.. Note: Entire file is gobbled in one-go. Useful only for small files.
f.read()        # gets entire file as one big string. Again, use for small files only.

Reading line by line from stdin:

import fileinput
for line in fileinput.input():   #this one will pick stdin or if some arg(s) is/are given, it will open that as a file!
  pass

import sys
for line in sys.stdin:
  print line

Arg parse
--------

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-v","--verbose", help="increase output verbosity", action="store_true")       # captures if --verbosity present or not in arg-list. No arg per-se for this option.
parser.add_argument("-v","--verbose", help="increase output verbosity", action="count")            # captures how many times --verbosity was present in arg-list. No arg per-se for this option.
parser.add_argument("-v","--verbose", help="increase output verbosity", type=int)                  # --verbosity <int>
parser.add_argument("-v","--verbose", help="increase output verbosity", type=int, choices=[0,1,2]) # --verbosity <0|1|2>
parser.add_argument("square", help="display a square of a given number (this is a positional argment)", type=int)

args = parser.parse_args()
if args.verbose:
      print("verbosity turned on")

also:
group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", action="store_true")
group.add_argument("-q", "--quiet", action="store_true")

argc/argv example
-----------------

if len(sys.argv) < 2:
    sys.exit('Usage: %s database-name' % sys.argv[0])

if not os.path.exists(sys.argv[1]):
    sys.exit('ERROR: Database %s was not found!' % sys.argv[1])

exiting from python
---------------------

sys.exit(0)

regular expression
------------------

import re
m =  re.search (pat, haystack)   # m is a match object or a None

m.group()  # gets the matched string
m.group(1)  # gets the 1st left paren group.

a = re.findall (pat, haystack)  # gets the list of all matches.. if he pat has (), then it gets back a list of tuples

os-package (file manipulation stuff)
----------

os.path.join(dir,filename)
(dirname,filename) = os.path.split("abc/efg/file")
(filename,extension) = os.path.splitext("filename.ext")  # note the spelling split-ext
os.path.abspath(path)
os.path.realpath(path)  # resolves sym-links!
os.path.exists('path/to/file')
os.path.isdir('path/to/dir')
os.makedirs(path)   # no mkdir -p option.. just check isdir and then do this or do , catch except (latter better)

import subprocess
subprocess.call(["ls","-l"])

import glob
list_of_filenames=glob.glob("*.py")

time
----

>>> import time
>>> st_mtime=1247520344.9537716
>>> time.localtime(st_mtime)
time.struct_time(tm_year=2009, tm_mon=7, tm_mday=13, tm_hour=14, tm_min=25, tm_sec=44, tm_wday=0, tm_yday=194, tm_isdst=1)
>>>

urllib
------

import urllib

uf = urllib.urlopen('http://google.com')
file_page = uf.read()

urllib.urlretrive('http://google.com/intl/en_ALL/images/logo.gif', 'blah.gif')

Find python version
-------------------

python -v


Python Internals
---------------

Every name you see is a reference/pointer to an object.
The underlying object is either an immutable object or a mutable object.

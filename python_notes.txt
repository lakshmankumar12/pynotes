Functions
-----------

* start with def
* no return type - either what return statement returns or None. (not last statement stuff)
* args have  no type either.
* function are objects too.. 
* invoked with fnName(args) [dont forget parenthesis for empty-arg fns]

eg:

def add(a,b):
  c=a+b
  return c

add(5,10)
  


Commenting comments
-------------------

* '''...''' right after the function defintion
* function.__doc__ is the way to get the doc-string of a function
* Simple comments begin with #

Exceptions

* No one defines what exceptions will be raised. We handle every possible exception

Data-types
===========

booleans
numbers
strings
bytes and byte-arrays
lists
tuples
sets
dictionaries

* use type(varaible) to check the type of a variable.

List
----

* list is [ .. ] separated by comma
* list elements are indexed from 0 and name[0] is the way to get one element
* -1 is the last element.
* slicing is first index to *one before* the second index. 
* Slicing creates a copy, so a[:] is a shorthand for getting a copy of a list
* lists never have gaps

len(a) 
a.append(one_value)
a.extend([list])
a.insert(index,value)
del a[index]
a.pop()  # pops the last index, gets a IndexError when we pop a empty list. List reduces after pop.
a.pop(index)  # pops given index
a.remove(value)  # pops vlaue. raises ValueError if value is not found
a.index(value)  # gives index of the value.

value in a # boolean expression to check if value is in a list.

+ operator concaetanates lists

Tuples
-----

* Use ( , .. , ) for types instead of squarebracket.
* (tuple1) = (tuple2) 
    eg: (x,y,z) = (1,2,3) is a conveneient way to assign multiple variables respectively 


Sets
-----

* Use { , .. , } for sets
* sets dont remember order of their elements
* values in the sets are unique. 

a.add(value)  # adds a value to set if its not already present.
a.update(value, set, list) # addes the value, members of set, list to the set.
a.discard(value)  # removes the value from set. No error if value not present
a.remove(value)  # removes the value from set. KeyError is raised if value not present.
a.pop()          # removes some arbitrary member from set. KeyError on empty set
a.clear()         # clears the set. same as a=set()

a.union(b)  # returns a *new* set that is union of a & b
a.intersection(b)
a.difference(b)             # in a not in b
a.symmetric_difference(b)   # in strictly only of a and b

Note: a= {} creates a empty *dictionary*, not set.

Dictionary
------------

* user { key:value } for dictionary

a[key] = value  # for assignment or referenence. Note they key is indexed using squre braket only!

list(a.keys())  # creates a list of keys of dictionary a

orig_dict.update(another_dict)

List comprehesion
------------------

[ expression-having-variable for variable in origList ]
[ expression-having-variable for variable in origList if condition ]

so is it with dictionary and set comprehesion


strings
---------

* Every string is a UTF-8 encoded sequence of characters.
* strings can be single or double-quoted. Triple single quotes is for long strings
* + is a way to concatenate strings

a.splitlines()       # list of lines. The restult wont have carriage returns.
a.lower()            # returns a new string that has all lower caps
a.upper()
a.count('f')         # counts no of substrings
a.split(delimiter,times)   # splits a string based on delimiter. THe second is optional and gives number of times the slice should be done.

a.encode('utf-8')    # gives a bytes object

a.index()
a.find()
a.replace()

a.strip()            # trim whitespaces
a.rstrip()
a.lstrip()

bytes
-----

defined as b'\xfe' or b'abc' 

a.decode('ascii')    # gives a string object

control structures
------------------

if condition:
  ...
elif next_condition:         #python's else if style
  ..
else
  ..

with lists.
  Use range function to run over a range.
  range(start-value, end-value+1, increment)

for i in list:
  ..use i..

for i in range(1,10):
  ..use i..

break
continue


Simple commands
----------------

print()

string.format(args)
'{0} {1:2d}'.format(s,i)

{arg-position:<width><type>}  # default type is string

older pythong:

print "format string %d, %s, %s"%(int_var,str_var,"string literal")


Error handling
--------------

try:

except IOError:

# Note its except and not expect


Reading file line by line:
--------------------------


with open("file","r") as fp:
  for i in fp
    print(i)

f.readline()

Reading line by line from stdin:

import fileinput      
for line in fileinput.input():   #this one will pick stdin or if some arg(s) is/are given, it will open that as a file!
  pass

import sys
for line in sys.stdin:
  print line

Arg parse
--------

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-v","--verbose", help="increase output verbosity",
                    action="store_true", choices=[0, 1, 2])             # or action="count
parser.add_argument("square", help="display a square of a given number (this is a positional argment)",
                     type=int)
args = parser.parse_args()
if args.verbose:
      print("verbosity turned on")

argc/argv example
-----------------

if len(sys.argv) < 2:
    sys.exit('Usage: %s database-name' % sys.argv[0])

if not os.path.exists(sys.argv[1]):
    sys.exit('ERROR: Database %s was not found!' % sys.argv[1])

exiting from python
---------------------

sys.exit(0)

Find python version
-------------------

python -v
